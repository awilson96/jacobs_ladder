import os

import pandas as pd

from .DataClasses import Scale
from .ScaleTree import ScaleTree

# TODO: Read in dfs to classify scales according to mode.
# TODO: Create a mechanism of rotating scales through their length to produce all possible scales, then eliminate duplicates

class ScaleClassifier:
    
    def __init__(self):
        self.df_dict = self.read_csv_files()
    
    def read_csv_files(self):
        """Read all of the .csv files in the possible_scales directory and convert them into DataFrames 

        Returns:
            dict: a dictionary of DataFrames representing the .csv files read in by the script
        """
        self.script_directory = os.path.dirname(os.path.abspath(__file__))
        self.csv_directory = os.path.join(self.script_directory, "possible_scales")
        
        dfs = {}
        for filename in os.listdir(self.csv_directory):
            if filename.endswith(".csv"):
                file_path = os.path.join(self.csv_directory, filename)
                df = pd.read_csv(file_path)

                if not df.empty:
                    df_name = os.path.splitext(filename)[0]
                    dfs[df_name] = df
                    
                else:
                    os.remove(file_path)
        return dfs
    
    def convert_intervals(self, starting_note: int):
        """Given a starting note, create a list of MIDI scales starting from that note upward to the octave

        Args:
            starting_note (int): A MIDI note number between 21 and 96 inclusive which serves as the starting note for a scale which ascends upwards 1 octave

        Returns:
            list: a list of scales starting from the starting note which meets the criteria of scales autogenerated by ScaleTree class
        """
        scale_list = []
        for df_name, df in self.df_dict.items():
            for index, row in df.iterrows():
                remainder = list(map(lambda x: x + starting_note, list(row.cumsum())))
                scale = [starting_note]
                scale.extend(remainder)
                scale_list.append(scale)
                
        return scale_list
    
    def create_harmonized_scale(self, scale: list, num_voices: int):
        """Given a scale as a list of MIDI notes and a number of voices, return a chord scale using that scale

        Args:
            scale (list): a list of integer notes (valid notes are in range 21-108 inclusive)
            num_voices (int): number of voices to play at one time in the chord scale (max number of voices is 5)

        Returns:
            list[list]: a list of chords which are within the provided scale
        """
        if not all(21 <= note <= 108 for note in scale):
            raise ValueError("All notes in the scale must be in the range 21-108 inclusive.")
        if num_voices < 1 or num_voices > 5:
            raise ValueError("Number of voices must be between 1 and 5.")
    
        starting_note = scale[0]
        scale_original = scale.copy()
        scale_pattern = [note - starting_note for note in scale]
        for _ in range(2):
            extension = [scale[-1] + note for note in scale_pattern]
            scale.extend(extension[1:])
        
        chord_scale = []
        for index in range(len(scale_original)):
            chord = []
            for num_voc in range(0, int(num_voices)*2, 2):
                chord.append(scale[index+num_voc])
            chord_scale.append(chord)
            
        return chord_scale

if __name__ == "__main__":
    pd.set_option('display.max_rows', None)
    sc = ScaleClassifier()
    scales = sc.convert_intervals(starting_note=60)
    my_scale = scales[0]
    chord_scale = sc.create_harmonized_scale(scale=my_scale, num_voices=3)
    print(chord_scale)